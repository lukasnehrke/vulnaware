package dev.lukasnehrke.vulnaware.vulnerability.service;

import com.google.api.services.sqladmin.model.User;
import dev.lukasnehrke.vulnaware.activity.model.type.VulnActivity;
import dev.lukasnehrke.vulnaware.activity.service.ActivityService;
import dev.lukasnehrke.vulnaware.advisory.model.Advisory;
import dev.lukasnehrke.vulnaware.advisory.repository.AdvisoryRepository;
import dev.lukasnehrke.vulnaware.bom.model.Bom;
import dev.lukasnehrke.vulnaware.bom.model.Metrics;
import dev.lukasnehrke.vulnaware.bom.repository.BomRepository;
import dev.lukasnehrke.vulnaware.notification.model.type.VulnNotification;
import dev.lukasnehrke.vulnaware.notification.service.NotificationService;
import dev.lukasnehrke.vulnaware.project.model.ProjectMember;
import dev.lukasnehrke.vulnaware.util.ResourceNotFoundProblem;
import dev.lukasnehrke.vulnaware.vulnerability.model.Vulnerability;
import dev.lukasnehrke.vulnaware.vulnerability.model.VulnerabilityStatus;
import dev.lukasnehrke.vulnaware.vulnerability.repository.VulnerabilityRepository;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.Nullable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StopWatch;

@Service
@AllArgsConstructor
public class VulnerabilityService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityService.class);
    private final VulnerabilityRepository repository;
    private final AdvisoryRepository advisories;
    private final BomRepository boms;
    private final ActivityService activityService;
    private final NotificationService notificationService;

    @Transactional(readOnly = true)
    public Vulnerability get(final Long id) {
        return repository.findById(id).orElseThrow(() -> new ResourceNotFoundProblem("Vulnerability", id));
    }

    @Transactional
    public List<Vulnerability> analyze(final Long id) {
        final var bom = this.boms.findById(id).orElseThrow();
        return analyze(bom);
    }

    @Async
    @Transactional
    public void analyzeLater(final Long id) {
        final var bom = this.boms.findById(id).orElseThrow();
        analyze(bom);
    }

    @Transactional
    public List<Vulnerability> analyze(final Bom bom) {
        final var watch = new StopWatch();

        final var now = new Date();
        final var lastAnalyzed = bom.getLastAnalyzedAt();

        // get advisories that have been updated since last analysis
        watch.start("fetch");
        final var advisoryList = lastAnalyzed == null
            ? this.advisories.selectByBom(bom.getId())
            : this.advisories.selectByBomAndDate(bom.getId(), lastAnalyzed);

        watch.stop();
        logger.info("Found {} possible advisories for bom '{}' ({}ms)", advisoryList.size(), bom.getId(), watch.getLastTaskTimeMillis());

        watch.start("match");
        final var vulns = new ArrayList<>(
            advisoryList
                .stream()
                .map(advisory -> createFromAdvisory(advisory, bom))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .peek(vuln -> updateMetrics(bom.getMetrics(), vuln.getAdvisory().getRisk()))
                .toList()
        );

        watch.stop();
        logger.info("Found {} new vulnerabilities for bom '{}' ({}ms)", vulns.size(), bom.getId(), watch.getLastTaskTimeMillis());

        // versioning
        for (Vulnerability existing : bom.getVulnerabilities()) {
            boolean found = false;
            for (Vulnerability vuln : vulns) {
                if (vuln.getAdvisory().getId().equals(existing.getAdvisory().getId())) {
                    vuln.setId(existing.getId());
                    found = true;
                }
            }

            // resolve vulnerabilities that affect no components
            if (!found && existing.getStatus() == VulnerabilityStatus.OPEN && existing.getComponents().isEmpty()) {
                existing.setStatus(VulnerabilityStatus.RESOLVED);
            }
        }

        bom.setLastAnalyzedAt(now);
        boms.save(bom);

        if (vulns.isEmpty()) {
            // no new vulnerabilities found
            return vulns;
        }

        repository.saveAll(vulns);

        // create activity
        final var activity = new VulnActivity();
        activity.setProject(bom.getProject());
        activity.setTag(bom.getTag());
        activity.setAmount(vulns.size());
        activityService.create(activity);

        // create notification
        for (ProjectMember member : bom.getProject().getMembers()) {
            final var notification = new VulnNotification();
            notification.setUser(member.getUser());
            notification.setProject(bom.getProject());
            notification.setVulnerabilities(vulns);
            notificationService.save(notification);
        }

        return vulns;
    }

    private Optional<Vulnerability> createFromAdvisory(final Advisory advisory, final Bom bom) {
        final var affected = advisory.isAffected(bom.getComponents());

        if (affected.isEmpty()) {
            // this advisory does not affect any component
            return Optional.empty();
        }

        final var vuln = new Vulnerability();
        vuln.setBom(bom);
        vuln.setAdvisory(advisory);
        vuln.setComponents(affected);

        return Optional.of(vuln);
    }

    private void updateMetrics(final Metrics metrics, @Nullable final Double score) {
        if (score == null) {
            return;
        }
        if (score > 9.0) {
            metrics.setRiskCriticalCount(metrics.getRiskCriticalCount() + 1);
            return;
        }
        if (score > 7.0) {
            metrics.setRiskHighCount(metrics.getRiskHighCount() + 1);
            return;
        }
        if (score > 4.0) {
            metrics.setRiskMediumCount(metrics.getRiskMediumCount() + 1);
            return;
        }
        if (score > 0.0) {
            metrics.setRiskLowCount(metrics.getRiskLowCount() + 1);
        }
    }
}
